<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ethereum/eth.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ethereum/eth.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { Log } from '../log'

import { NodeWallet, LedgerWallet } from './wallets'
import { Contract } from './Contract'
import { Abi } from './abi'
import { ethUtils } from './ethUtils'
import { promisify } from '../utils/index'

const log = new Log('Ethereum')
let web3 = null

/** @namespace */
export const eth = {
  /**
   * Filled on .connect()
   */
  contracts: {},
  wallet: null,

  /**
   * Reference to the utilities object {@link ethUtils}
   */
  utils: ethUtils,

  /**
   * Connect to web3
   * @param  {object} [options] - Options for the ETH connection
   * @param  {array&lt;Contract>} [options.contracts=[]] - An array of objects defining contracts or Contract subclasses to use. Check {@link eth#setContracts}
   * @param  {string} [options.defaultAccount=web3.eth.accounts[0]] - Override the default account address
   * @param  {string} [options.providerUrl] - URL for a provider forwarded to {@link Wallet#getWeb3Provider}
   * @param  {string} [options.derivationPath] - Path to derive the hardware wallet in. Defaults to each wallets most common value
   * @return {boolean} - True if the connection was successful
   */
  async connect(options = {}) {
    if (this.isConnected()) {
      this.disconnect()
    }

    const {
      contracts = [],
      defaultAccount,
      providerUrl,
      derivationPath
    } = options

    try {
      this.wallet = await this.connectWallet(
        defaultAccount,
        providerUrl,
        derivationPath
      )
      web3 = this.wallet.getWeb3()

      this.setContracts(contracts)

      return true
    } catch (error) {
      log.info(`Error trying to connect Ethereum wallet: ${error.message}`)
      return false
    }
  },

  async connectWallet(defaultAccount, providerUrl = '', derivationPath = null) {
    let wallet
    const networks = this.getNetworks()

    try {
      const network =
        networks.find(network => providerUrl.includes(network.name)) ||
        networks[0]

      wallet = new LedgerWallet(defaultAccount, derivationPath)
      await wallet.connect(providerUrl, network.id)
    } catch (error) {
      wallet = new NodeWallet(defaultAccount)
      await wallet.connect(providerUrl)
    }

    return wallet
  },

  isConnected() {
    return (this.wallet &amp;&amp; this.wallet.isConnected()) || !!web3
  },

  disconnect() {
    if (this.wallet) {
      this.wallet.disconnect()
    }
    this.wallet = null
    this.contracts = {}
    web3 = null
  },

  getAddress() {
    return this.getAccount()
  },

  getAccount() {
    return this.wallet.getAccount()
  },

  getWalletAttributes() {
    return {
      account: this.wallet.account,
      type: this.wallet.type,
      derivationPath: this.wallet.derivationPath
    }
  },

  /**
   * Set the Ethereum contracts to use on the `contracts` property. It builds a map of
   *   { [Contract Name]: Contract instance }
   * usable later via `.getContract`. Check {@link https://github.com/decentraland/commons/tree/master/src/ethereum} for more info
   * @param  {array&lt;Contract|object>} contracts - An array comprised of a wide variety of options: objects defining contracts, Contract subclasses or Contract instances.
   */
  setContracts(contracts) {
    if (!this.isConnected()) {
      throw new Error(
        'Tried to set eth contracts without connecting successfully first'
      )
    }

    for (const contractData of contracts) {
      let contract = null
      let contractName = null

      if (typeof contractData === 'function') {
        // contractData is subclass of Contract
        contract = new contractData()
        contractName = contractData.getContractName()
      } else if (
        typeof contractData === 'object' &amp;&amp;
        contractData.constructor !== Object
      ) {
        // contractData is an instance of Contract or of one of its subclasses
        contract = contractData
        contractName = contractData.constructor.getContractName()
      } else {
        // contractData is an object defining the contract
        contract = new Contract(contractData)
        contractName = contractData.name
      }

      if (!contractName) continue // skip

      const instance = this.wallet.createContractInstance(
        contract.abi,
        contract.address
      )
      contract.setInstance(instance)

      this.contracts[contractName] = contract
    }
  },

  /**
   * Get a contract instance built on {@link eth#setContracts}
   * It'll throw if the contract is not found on the `contracts` mapping
   * @param  {string} name - Contract name
   * @return {object} contract
   */
  getContract(name) {
    if (!this.contracts[name]) {
      const contractNames = Object.keys(this.contracts)
      throw new Error(
        `The contract ${name} not found.\nDid you add it to the '.connect()' call?\nAvailable contracts are "${contractNames}"`
      )
    }

    return this.contracts[name]
  },

  /**
   * Interface for the web3 `getTransaction` method
   * @param  {string} txId - Transaction id/hash
   * @return {object}      - An object describing the transaction (if it exists)
   */
  async fetchTxStatus(txId) {
    return await promisify(web3.eth.getTransaction)(txId)
  },

  /**
   * Interface for the web3 `getTransactionReceipt` method. It adds the decoded logs to the result (if any)
   * @param  {string} txId - Transaction id/hash
   * @return {object} - An object describing the transaction receipt (if it exists) with it's logs
   */
  async fetchTxReceipt(txId) {
    const receipt = await promisify(web3.eth.getTransactionReceipt)(txId)

    if (receipt) {
      receipt.logs = Abi.decodeLogs(receipt.logs)
    }

    return receipt
  },

  async sign(payload) {
    const message = this.utils.toHex(payload)
    const signature = await this.wallet.sign(message)
    return { message, signature }
  },

  async recover(message, signature) {
    return await this.wallet.recover(message, signature)
  },

  /**
   * Get a list of known networks
   * @return {array} - An array of objects describing each network: { id, name, label }
   */
  getNetworks() {
    return [
      {
        id: '1',
        name: 'mainnet',
        label: 'Main Ethereum Network'
      },
      {
        id: '2',
        name: 'morden',
        label: 'Morden Test Network'
      },
      {
        id: '3',
        name: 'ropsten',
        label: 'Ropsten Test Network'
      },
      {
        id: '4',
        name: 'rinkeby',
        label: 'Rinkeby Test Network'
      },
      {
        id: '42',
        name: 'kovan',
        label: 'Kovan Test Network'
      }
    ]
  },

  /**
   * Interface for the web3 `getNetwork` method (it adds the network name and label).
   * @return {object} - An object describing the current network: { id, name, label }
   */
  async getNetwork() {
    const id = await promisify(web3.version.getNetwork)()
    const networks = this.getNetworks()
    const network = networks.find(network => network.id === id)
    if (!network) {
      throw new Error('Unknown Network')
    }
    return network
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Contract.html">Contract</a></li><li><a href="DecentralandVesting.html">DecentralandVesting</a></li><li><a href="ERC20Token.html">ERC20Token</a></li><li><a href="ERC721Token.html">ERC721Token</a></li><li><a href="Event.html">Event</a></li><li><a href="LANDRegistry.html">LANDRegistry</a></li><li><a href="MANAToken.html">MANAToken</a></li><li><a href="Marketplace.html">Marketplace</a></li><li><a href="ReturnMANA.html">ReturnMANA</a></li><li><a href="ServiceLocator.html">ServiceLocator</a></li><li><a href="SignedMessage.html">SignedMessage</a></li><li><a href="SMTP_SMTP.html">SMTP</a></li><li><a href="TerraformReserve.html">TerraformReserve</a></li></ul><h3>Namespaces</h3><ul><li><a href="eth.html">eth</a></li><li><a href="ethUtils.html">ethUtils</a></li><li><a href="mailchimp.html">mailchimp</a></li><li><a href="mongo.html">mongo</a></li><li><a href="postgres.html">postgres</a></li><li><a href="tunnel.html">tunnel</a></li><li><a href="txUtils.html">txUtils</a></li></ul><h3>Global</h3><ul><li><a href="global.html#arrayToObject">arrayToObject</a></li><li><a href="global.html#confirm">confirm</a></li><li><a href="global.html#extractFromReq">extractFromReq</a></li><li><a href="global.html#handleRequest">handleRequest</a></li><li><a href="global.html#isEmptyObject">isEmptyObject</a></li><li><a href="global.html#mapOmit">mapOmit</a></li><li><a href="global.html#omit">omit</a></li><li><a href="global.html#pick">pick</a></li><li><a href="global.html#promisify">promisify</a></li><li><a href="global.html#prompt">prompt</a></li><li><a href="global.html#runProgram">runProgram</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#useRollbar">useRollbar</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Mar 25 2018 21:16:07 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
